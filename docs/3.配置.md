## [目录](https://github.com/jhq0113/yafr/blob/master/docs/index.md)


## [2.Hello World](https://github.com/jhq0113/yafr/blob/master/docs/2.HelloWorld.md)

# 配置

## 1.1 运行时配置
|配置名称|默认值|含义|
|:-----|:--- |:---|
|yaf.library|无|全局路径，Yaf_loader会从这个目录检索全局库|
|yaf.action_prefer|0|如果路径信息中只有一部分，当设置为0时，会把这部分作为controller，如果设置为1，会把这部分作为action|
|yaf.lowcase_path|0|在类自动加载过程中是否将所有的路径转换为小写|
|yaf.use_spl_autoload|0|当设置为0时，Yaf_Loader::autoload()将一直返回true,设置为1时，如果Yaf_Loader找不到类时，将返回false,由其他自动加载方法处理|
|yaf.forward_limit|5|Yaf_Controller_Abstract::forward()的最大次数，防止递归次数过多，设置最大保护机制|
|yaf.name_suffix|1|当设置为1时，Yaf_Loader将根据类后缀名判断是否是一个MVC类，若设置为0，将根据类前缀名判断|
|yaf.name_separator|无|当该值不为空时，Yaf_Loader将根据这个值来鉴定类后缀和值，如：当值为"_"时，Yaf_Loader将把Index_Controller作为控制器类，IndexController作为普通类|
|yaf.cache_config|0|当设置为1时，同时使用ini配置文件作为Yaf_Application()的参数时，ini配置文件的编译结果将被缓存到php进程中，Yaf根据ini文件的mtime判断配置是否更新，如果更新，Yaf将重新加载ini配置，注意，yaf使用ini文件路径作为缓存key，所以在ini文件路径中使用绝对路径，否则，如果两个应用程序使用相同的ini配置相对路径，可能会出现一些冲突。|
|yaf.environ|product|用于yaf获取ini配置文件的config部分，如果该值为“product”，那么yaf将使用ini配置文件（Yaf_Application第一个参数）中名为“product”的部分作为Yaf_Application的最终配置。|
|yaf.use_namespace|0|当设置为1时，Yaf所有的类都将以命名空间的方式使用|